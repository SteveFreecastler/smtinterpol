BASIC PROOF RULES

OLD:
(@res c1 (! c2 :pivot ~ell2) (! c3 :pivot ell3))

NEW:
(res ell3
  c3
  (res ell2
    c1
    c2))

OLD:
(@eq (@assert t1) (@assert (= t1 t2)))

NEW:
(res t1
  (assert t1)
  (res (= t1 t2)            # ~t1, t2
    (assert (= t1 t2))
    (=-2 (= t1 t2)))        # ~(= t1 t2), ~t1, t2

OLD:
(@refl t)

NEW:
(trans t)

OLD:
(@trans (@assert (= t1 t2)) (@assert (= t2 t3)))

NEW:
(res (= t1 t2)
  (assert (= t1 t2))
  (res (= t2 t3)
    (assert (= t2 t3))
    (trans t1 t2 t3)       # (= t1 t3), ~(= t1 t2), ~(= t2 t3)

OLD:
(@cong (@assert (= t (f t1 t2 t3))) (@assert (= t2 t2')))

NEW:
(res (= t (f t1 t2 t3))
  (assert (= t (f t1 t2 t3)))
  (res (= (f t1 t2 t3) (f t1 t2' t3))
     (res (= t3 t3)
       (trans t3)
       (res (= t2 t2')
         (assert (= t2 t2'))
	 (res (= t1 t1)
	   (trans t1)
           (cong f t1 t1 t2 t2' t3 t3))))
     (trans t (f t1 t2 t3) (f t1 t2' t3))


CLAUSE:

OLD
(@clause (@asserted (or a b c a e d e))
   (! (or a e d c b) :input))

NEW:
(res (or a b c d e)
  (assert (or a b c a e d e))
  (or- a b c a e d e)

SPLIT RULES

OLD:
(@clause (@split (! (@asserted (not (or p (not q) r))) :notOr) (not r))
         (! (not r) :input))


NEW:
(res (or p (not q) r)
  (or+ 2 (or p (not q) r))              # (or p (not q) r), ~r
  (res (not (or (p (not q) r)))         # ~(or p (not q) r)
     (assert (not (or (p (not q) r))))
     (not- (or (p (not q) r))))

or with let:

(let ((bigor (or p (not q) r)))
  (res bigor
    (or+ 2 bigor)
    (res (not bigor)
      (assert (not bigor))
      (not- bigor))))

similar for and:

(let ((bigand (and (not p) q (not r))))
  (res (not r)
    (res bigand
      (assert bigand)
      (and- 2 bigand))      # ~(and (not p) q (not r)), (not r)
    (not- r)                # ~(not r), ~r


OLD:
(@clause
  (@split (! (@asserted (not (ite p q r))) :ite-1) (or (not p) (not q)))
  (! (or (not p) (not q)) :input))

NEW:

(res (ite p q r)
  (res (= (ite p q r) q)
    (ite1 p q r)                 # (= (ite p q r) q), ~p
    (=-1 (= (ite p q r) q)))     # ~(= (ite p q r) q), (ite p q r), ~q
  (res (not (ite p q r))
     (assert (not (ite p q r)))
     (not- (ite p q r)))         # ~(not (ite p q r)), ~(ite p q r)


TAUTOLOGY RULES


OLD:
(@tautology (! (or (not F) (= F true)) :excludedMiddle1))
NEW:
(res true
  true+
  (=+2 F true))


OLD:
(@tautology (! (or F (= F false)) :excludedMiddle2))
NEW:
(res false
  (=+1 F false)
  false-)

OLD:
(@tautology (! (or (! (ite c a b) :quoted) (not a) (not b)) :ite-red))
  # (ite c a b), ~a, ~b


NEW:

(res (= (ite c a b) b)      # (ite c a b), ~a, ~b
  (res (= (ite c a b) a)    # (= (ite c a b) b), (ite c a b), ~a
    (res c                  # (= (ite c a b) b), (= (ite c a b) a)
      (ite2 c a b)          # (= (ite c a b) b), c
      (ite1 c a b)          # (= (ite c a b) a), ~c
    (=-1 (= (ite c a b) a)  # ~(= (ite c a b) a), (ite c a b), ~a
  (=-1 (= (ite c a b) b)    # ~(= (ite c a b) b), (ite c a b), ~b

OLD:
(@tautology (! (not (= true false)) :trueNotFalse))

NEW:
(res false
  (res true
    true+
    (=-2 true false))          # ~(= true false), ~true, false
  false-)


REWRITE RULES

OLD:
(@rewrite (! (= (not (not t)) t) :notNot))
NEW:
(res t                     # (= (not (not t)) t)
  (res (= not (not t))
    (=+1 (not (not t)) t)  # (= (not (not t)) t), (not (not t)), t
    (res (not t)           # ~(not (not t)), t
      (not+ t)             # (not t), t
      (not- (not t))))     # ~(not (not t)), ~(not t)
  (res (= not (not t))
    (=+2 (not (not t)) t)  # (= (not (not t)) t), ~(not (not t)), ~t
    (res (not t)           # (not (not t)), ~t
      (not+ (not t))
      (not- t))))

OLD:
(@rewrite (! (= (= true false) false) :trueNotFalse))
NEW:
(res false
  (res true
    true+
    (res (= true false)           # (= (= true false) false), ~true, false
      (=+1 (= true false) false)  # (= (= true false) false), (= true false), false
      (=-2 true false)))          # ~(= true false), ~true, false
  false-)

OLD:
(@rewrite (! (= (ite t true false) t) :iteBool1))

NEW:
 (ite1 t true false)       # (= (ite t true false) true), ~t

(res t
  (res (= (ite t true false) false)   # (= (ite t true false) t), t
     (ite2 t true false)              # (= (ite t true false) false), t
     (res (= false t)
        (res false                    # (= false t), t
	   (=+1 false t)              # (= false t), false, t
	   false-)
        (trans (ite t true false) false t)))
  (res (= (ite t true false) true)    # (= (ite t true false) t), ~t
     (ite1 t true false)              # (= (ite t true false) true), ~t
     (res (= true t)
        (res true                     # (= true t), ~t
	   true+
	   (=+2 true t))              # (= true t), ~true, ~t
        (trans (ite t true false) true t)))


OR:
(res t
  (res (ite t true false)                 # (= (ite t true false) t), t
    (=+1 (ite t true false) t)            # (= (ite t true false) t), (ite t true false), t
    (res false                            # ~(ite t true false), t
      (res (= (ite t true false) false)   # ~(ite t true false), false, t
        (ite2 t true false)               # (= (ite t true false) false), t
        (=-2 (ite t true false) false))
      false-))
  (res (ite t true false)                 # (= (ite t true false) t), ~t
    (res true                             # (ite t true false), ~t
      true+
      (res (= (ite t true false) true)    # (ite t true false), ~true, ~t
        (ite1 t true false)               # (= (ite t true false) true), ~t
        (=-1 (ite t true false) true)))
    (=+2 (ite t true false) t))           # (= (ite t true false) t), ~(ite t true false), ~t



FLATTEN:


(@clause
  (@eq (@asserted (or (or a b) (or c d)))
       (@rewrite (= (or (or a b) (or c d)) (or a b c d)) :flatten)))


(res (or a b)                      # a, b, c, d
  (res (or c d)                    # (or a b), c, d
    (res (or (or a b) (or c d))    # (or a b), (or c d)
      (assert (or (or a b) (or c d)))
      (or- (or a b) (or c d)))
    (or- (or c d)))
  (or- (or a b)))



OLD:
(@rewrite (= (store (store a i v) i w) (store a i w)) :storeOverStore)


NEW:
(let ((store1 (store a i w)) (store2 (store (store a i v) i w)))
(res (= (select store2 (diff store2 store1)) (select store1 (diff store2 store1)))
  (res (= (diff store2 store1) i)
    (res (= (select store2 (diff store2 store1)) w)
      (cong select store2 store2 (diff store2 store1) i)
      (selectstore1 (store a i v) i w)
      (res (= (select store1 (diff store2 store1)) w)
        (cong select store1 store1 (diff store2 store1) i)
        (selectstore1 a i w))
          (symm ...))
    (res
      (selectstore2 (store a i v) i w (diff store2 store1))
      (selectstore2 a i v (diff store2 store1))
      (res
	 (symm (select a (diff store2 store1))
	       (select store1 (diff store2 store1)))
         (selectstore2 a i w (diff store2 store1)))
      (trans (select store2 (diff store2 store1))
             (select (store a i v) (diff store2 store1))
             (select a (diff store2 store1))
	     (select store1 (diff store2 store1)))))
  (extdiff store2 store1)))






(= (and t1 .. tn) (not (or (not t1)... (not tn))))

 =+1
 =+2


How to prove xor things:

(xorunitt+ t): (xor t true), t
(res true
  true+
  (xor+ (t true) (t) (true)))   # ~true, (xor t true), t

(xorunitf+ t): (xor t false), ~t
(res false
  (xor+ (t false) (false) (t))
  false-)

(xorunitt- t): ~(xor t true), ~t
(res true
  true+
  (xor- (t true) (t) (true)))

(xorunitf- t): ~(xor t false), t
(res false
  (xor+ (t false) (false) (t))
  false-)

(notxor t): ~(xor t t)
(res false
  (xor+ (false) (false) (t t))    # ~(xor t1 t1), false
  false-)


(xornot t): (xor t (not t))
(res t
  (res (not t)
    (not+ t)
    (xor+ (t (not t)) (t) ((not t))))   # (xor t (not t)), t, ~(not t)
  (res (not t)
    (xor+ (t (not t)) ((not t)) (t))    # (xor t (not t)), (not t), ~t
    (not- t)))

(xor t1 ... (not ti) ... tn), (xor t1 ... ti ... tn):
(res (xor t (not t))
  (xornot t)
  (xor+ (t1 ... (not ti) ... tn) (xor t1 ... ti ... tn) (t (not t))))


~(xor t1 ... (not ti) ... tn), ~(xor t1 ... ti ... tn):
(res (xor t (not t))
  (xornot t)
  (xor- (t1 ... (not ti) ... tn) (xor t1 ... ti ... tn) (t (not t))))
